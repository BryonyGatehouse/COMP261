A* ALGORITHM

(when distTime is true sort by dist, else by time)
ASearch(startNode, finishNode){
	set all node's prev/prevSeg to null and visited to false
	start fringe with single element <finishNode, null, 0, f(start), null, distTime>; 
	While (the fringe is not empty) {
		Expand <n*,p*,g*,f*,s*,d*> from the fringe, 
			where f* is minimal among all the elements in the fringe;
		if (n* is unvisited) {
			Set n* as visited, and set n*.prev = p*, and n*.prevSeg = s*;
			if (node* is StartNode) break;
			for (edge = (node*, neigh) outgoing from node*) {
				if (neigh is unvisited) {
					if (no restriction on turn)
						g = g* + g(n*);
						f = g + f(n*);
						add a new element <neigh,node*,g,f, edge, distTime> into the fringe; }
			} }
	}
}
Obtain the shortest path based on the .prev fields (easier with prevSeg field)

ITERATIVE ARTICULATION POINT ALGORITHM

Initialise depth for all (node) = ∞, APs = {};
	Randomly select a node as the root node, set depth(root) = 0,
	findArticulationPoints(root)
	Until all node.depth < ∞
		Randomly select a node with node.depth = ∞ as the root node, set depth(root) = 0,
		find ArticulationPoints(node)
	
	findArticulationPoints(root){
		for (each neighbour of root) { 
			if (depth(neighbour) = ∞) {
				iterArtPts(neighbour, 1, root);
				numSubTrees ++; 
			} 
		}
		if (numSubTrees > 1) 
			then add root into APs; 
	}
		
	iterArtPts(firstNode, depth, root) {
		Initialise stack as a single element <firstNode, depth, root>; 
		repeat until (stack is empty) {
			peek <n*, depth*, parent*> from stack; 
			if (depth(n*) = ∞) {
				depth (n*) = depth, reachBack(n*) = depth;
				children(n*) = all the neighbours of n* except parent*; 
			}
			else if (children(n*) is not empty) {
				get a child from children(n*) and remove it from children(n*);
				if (depth(child) < ∞) 
					then reachBack(n*) = min(depth(child), reachBack(n*)); 
				else 
					push <child, depth+1, n*> into stack; 
			}
			else {
				if (n* is not firstNode) {
					reachBack(parent*) = min(reachBack(n*), reachBack(parent*));
					if (reachBack(n*) >= depth(parent*)
						then add parent* into APs; 
				}
				remove <n*, depth*, parent*> from stack; 
			}
		}
	}
